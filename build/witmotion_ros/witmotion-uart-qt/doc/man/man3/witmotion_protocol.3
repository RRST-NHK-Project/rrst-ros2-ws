.TH "witmotion_protocol" 3 "Mon Feb 17 2025 17:07:52" "Version 1.2.28~dev_5c2e86d" "Witmotion IMU Library" \" -*- nroff -*-
.ad l
.nh
.SH NAME
witmotion_protocol \- Unified Witmotion communication protocol 
.PP
The communication protocol for all known Witmotion IMU sensor devices is unified\&. It bases on TTL UART communication circuits\&. Please refer to \fBofficial documentation\fP for complete description\&. UART initiates connection on the baudrate which should be already set in the sensor's memory\&.
.SH "Connection mode"
.PP
Parameter   Value   \fCQSerialPort\fP config constant    \fBPort mode\fP   Full Duplex   \fCQSerialPort::Direction::AllDirections\fP    \fBStart Bit\fP   0   \fC0x00\fP    \fBStop Bit\fP   1   \fCQSerialPort::OneStop\fP    \fBHardware Flow Control\fP   Off   \fCQSerialPort::FlowControl::NoFlowControl\fP   
.SS "Supported baud rates"
The known sensors support the following baud rates (the non-standard rates unsupported in \fCQSerialPort\fP are noticed with \fIitalic\fP):
.IP "\(bu" 2
2400
.IP "\(bu" 2
4800
.IP "\(bu" 2
9600 (default for open-circuit devices),
.IP "\(bu" 2
19200
.IP "\(bu" 2
38400
.IP "\(bu" 2
57600
.IP "\(bu" 2
115200 (default for enclosed devices with built-in USB/TTL transceiver)
.IP "\(bu" 2
\fI230400\fP
.IP "\(bu" 2
\fI256000\fP
.IP "\(bu" 2
\fI460800\fP
.IP "\(bu" 2
\fI921600\fP 
.PP
\fBNote\fP
.RS 4
The non-standard baudrated are not supported officially by \fCQSerialPort\fP backend\&. However, the \fCofficial Windows controller application\fP by Witmotion allows to set up the device with these values\&. If this would be occasionally done, the Qt backend cannot connect to the device, and the user is strongly advised to reduce baud rate via the same Windows controller application to 115200 baud manually before proceed\&.
.RE
.PP

.PP
.SH "Packet structures"
.PP
The device throws out the \fIdata packets\fP containing the measured values and accepts \fIconfiguration packets\fP to set up the parameters on-the-fly\&. The internal data representations for both types of packets are unified\&. For actual declarations refer to \fBtypes\&.h\fP header file\&.
.SS "Output data packet"
The output data are organized in 11-byte sequential packets by the following principle: Offset   Length   Description    \fC0x00\fP   1   Magic header key, \fBWITMOTION_HEADER_BYTE\fP    \fC0x01\fP   1   Data type ID, as defined in \fBwitmotion_packet_id\fP\&. All supported packet IDs should be enumerated in \fBwitmotion_registered_ids\fP list and described in \fBwitmotion_packet_descriptions\fP map in \fBtypes\&.h\fP header file, otherwise the library will not consider it as available to support\&.    \fC0x02\fP   8   Payload\&. The payload is organized as sequential byte array wrapped into C-style union\&. It can store: 
.br
 - 8 8-bit \fIsigned\fP integers $ \left[ -127 ... 128 \right] $ 
.br
 - 8 8-bit \fIunsigned\fP integers $ \left[ 0 ... 255 \right] $ 
.br
 - 4 16-bit \fIsigned\fP integers 
.br
 - 2 32-bit \fIsigned\fP integers    \fC0x0A\fP   1   Validation CRC\&. Calculated as a result of summation over all the \fBbytes\fP, not elements, as \fIunsigned\fP integers: 
.br
 $ crc = \sum_{i=0}^{i < 10}\times$\fCreinterpret_cast<uint8_t*>(payload) + i\fP   
.PP
The data packet structure is internally represented by \fBwitmotion_datapacket\fP structure\&.
.SS "Configuration data packet"
Configuration packets are 5-bytes sequential structures organized as it is shown in the following table\&. CRC check is not implemented on the device\&. Offset   Length   Description    \fC0x00\fP   1   Magic header key, \fBWITMOTION_CONFIG_HEADER\fP    \fC0x01\fP   1   Magic configuration packet ID, \fBWITMOTION_CONFIG_KEY\fP    \fC0x02\fP   1   Register ID, as defined in \fBwitmotion_config_register_id\fP    \fC0x03\fP   2   Payload\&. The set of 1 or 2 values that should be set on the device, represented as two 8-bit or one 16-bit unsigned integer   
.PP
The configuration packet has an internal representation in \fBwitmotion_config_packet\fP structure\&.
.SH "Data decoding algorithms and decoder functions"
.PP
The type-specific descriptions for payload components encapsulated in output data packet, are placed in \fBwitmotion_packet_id\fP enumeration documentation\&. The component decoder functions and packet parsers are located in \fButil\&.h\fP header file\&. In the following table the actual measurements are enumerated with corresponding decoding rules and output types\&. The rules are defined here only for the cases when the special decoding is needed\&. Otherwise the values should be interpreted exactly as they are defined in \fBwitmotion_packet_id\fP via direct copy\&.
.PP
Here and below, $ V $ is the \fBmeasured\fP value obtained from the device, $ D $ - \fBdecoded\fP value, de-normalized from the sensor output\&. Value   Unit   Decoding rule   Output type    Acceleration   $ m/s^2 $   $ D = 16\frac{V}{32768} \times 9.81 $   float    Angular velocity   $ rad/s $   $ D = \frac{V}{32768} \times 2000 $   float    Euler angle   $ deg $   $ D = \frac{V}{32768} \times 180 $   float    Temperature   $ ^{\circ}C $   $ D = \frac{V}{100} $   float    Quaternion component   $ D = \frac{V}{32768} $   float    Altimetry   $ m $   $ D = \frac{V}{100} $   float    GPS coordinate, rough/degrees part   $ deg $   $ D = \frac{V}{10^8} $   double-precision float    GPS coordinate, fine/minute part   $ min $   $ D = \frac{V \mod 10^7}{10^5} $   double-precision float    GPS altimetry   $ m $   $ D = \frac{V}{10} $   float    GPS angular velocity   $ rad/s $   $ D = \frac{V}{10} $   float    GPS ground speed   $ m/s $   $ D = \frac{V}{10^3} $   double-precision float   
.PP
\fBNote\fP
.RS 4
Some values like temperature, require different coefficients on different sensors\&. These values require linear calibration\&. If you encounter this situation, please do not hesitate to open an \fCissue\fP\&. 
.RE
.PP

